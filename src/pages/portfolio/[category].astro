---
import { Image, getImage } from 'astro:assets';
import BaseLayout from '../../layouts/BaseLayout.astro';
import Breadcrumbs from '../../components/Breadcrumbs.astro';
import Lightbox from '../../components/Lightbox.astro';
import { getImageByPath } from '../../utils/imageLoader';
import { getAllCategories, getAllCategoryPhotos, getPhotoPath } from '../../utils/db';

export async function getStaticPaths() {
  // Get categories from database
  const categories = getAllCategories();

  return categories.map(category => ({
    params: { category },
    props: { category },
  }));
}

const { category } = Astro.props;

// Get all photos for this category from database
const photos = getAllCategoryPhotos(category);

// Process photos with dimensions
const categoryImages = await Promise.all(
  photos.map(async (photo) => {
    const imagePath = getPhotoPath(photo);

    // Get imported image from src/images
    const importedImage = getImageByPath(imagePath);

    if (!importedImage) {
      console.warn(`Could not find imported image for ${imagePath}`);
      return {
        src: imagePath,
        alt: photo.alt,
        caption: photo.caption,
        location: photo.location,
        country: photo.country,
        sub_category: photo.sub_category,
        aspectRatio: 1.5,
        lightboxSrc: imagePath,
        originalSrc: imagePath,
        importedImage: undefined,
      };
    }

    // Get aspect ratio from imported image metadata
    const aspectRatio = importedImage.width / importedImage.height;

    // Generate optimized lightbox version (skip for SVG files)
    const isSvg = imagePath.toLowerCase().endsWith('.svg');
    let lightboxSrc = imagePath;

    if (!isSvg) {
      try {
        // Calculate target height based on aspect ratio
        const targetHeight = Math.round(1920 / aspectRatio);

        const lightboxImage = await getImage({
          src: importedImage,
          width: 1920,
          height: targetHeight,
          format: 'webp',
          quality: 85,
        });
        lightboxSrc = lightboxImage.src;
      } catch (error) {
        console.warn(`Could not optimize lightbox image for ${imagePath}:`, error.message);
        // Fall back to original image
        lightboxSrc = imagePath;
      }
    }

    return {
      src: imagePath,
      alt: photo.alt,
      caption: photo.caption,
      location: photo.location,
      country: photo.country,
      sub_category: photo.sub_category,
      aspectRatio,
      lightboxSrc,
      originalSrc: imagePath,
      importedImage,
    };
  })
);

// Group images by sub_category
const imagesBySubCategory = categoryImages.reduce((acc, image) => {
  const subCategory = image.sub_category || 'Other';
  if (!acc[subCategory]) {
    acc[subCategory] = [];
  }
  acc[subCategory].push(image);
  return acc;
}, {} as Record<string, typeof categoryImages>);

// Sort sub-categories alphabetically, with "Other" at the end
const sortedSubCategories = Object.entries(imagesBySubCategory).sort((a, b) => {
  if (a[0] === 'Other') return 1;
  if (b[0] === 'Other') return -1;
  return a[0].localeCompare(b[0]);
});

// Category display names
const categoryNames: Record<string, string> = {
  nature: 'Nature',
  street: 'Street Photography',
  concert: 'Concert Photography',
  other: 'Other',
};

const categoryName = categoryNames[category] || category;

// Helper function to create justified rows
function createJustifiedRows(images: any[], containerWidth: number = 1200, targetHeight: number = 300, gap: number = 16) {
  const rows: any[][] = [];
  let currentRow: any[] = [];
  let currentRowWidth = 0;

  images.forEach((image, index) => {
    // Default aspect ratio if dimensions not available
    const aspectRatio = image.aspectRatio || 1.5;
    const imageWidth = targetHeight * aspectRatio;

    // Check if adding this image would exceed container width
    if (currentRow.length > 0 && currentRowWidth + imageWidth + gap > containerWidth) {
      // Finalize current row
      rows.push([...currentRow]);
      currentRow = [];
      currentRowWidth = 0;
    }

    // Add image to current row
    currentRow.push({ ...image, index });
    currentRowWidth += imageWidth + (currentRow.length > 1 ? gap : 0);
  });

  // Add remaining images as last row
  if (currentRow.length > 0) {
    rows.push(currentRow);
  }

  return rows;
}
---

<BaseLayout
  title={`${categoryName} - Photography Portfolio`}
  description={`Browse my ${categoryName.toLowerCase()} photography, organized by theme.`}
>
  <div class="container mx-auto px-4 py-12">
    <Breadcrumbs items={[
      { label: 'Portfolio', href: '/portfolio' },
      { label: categoryName }
    ]} />

    <!-- Header -->
    <div class="text-center mb-12">
      <h1 class="text-4xl md:text-5xl font-bold mb-4">{categoryName}</h1>
      <p class="text-xl text-gray-600 dark:text-gray-400">
        {categoryImages.length} {categoryImages.length === 1 ? 'photo' : 'photos'}
        {sortedSubCategories.length > 0 && ` across ${sortedSubCategories.length} ${sortedSubCategories.length === 1 ? 'theme' : 'themes'}`}
      </p>
    </div>

    <!-- Images grouped by sub-category -->
    {sortedSubCategories.map(([subCategory, images]) => {
      // Images already have aspectRatio from Sharp metadata
      const subCategoryImages = images.map((image, index) => ({
        ...image,
        index,
      }));

      // Create justified rows (simpler approach: use CSS flexbox)
      return (
        <section class="mb-16" id={subCategory.toLowerCase().replace(/\s+/g, '-')}>
          <div class="mb-6">
            <h2 class="text-3xl font-bold">{subCategory}</h2>
            <p class="text-gray-600 dark:text-gray-400 mt-1">
              {images.length} {images.length === 1 ? 'photo' : 'photos'}
            </p>
          </div>

          <!-- Justified grid layout -->
          <div class="flex flex-wrap gap-4 justify-start">
            {subCategoryImages.map((image, index) => {
              // Calculate flex-basis based on aspect ratio
              // Target row height of ~280px, adjust width based on aspect ratio
              const targetHeight = 280;
              const flexBasis = targetHeight * image.aspectRatio;

              return (
                <button
                  type="button"
                  class="category-photo group relative overflow-hidden rounded-lg cursor-pointer text-left border-0 p-0 bg-transparent flex-grow-0"
                  style={`flex-basis: ${flexBasis}px; height: ${targetHeight}px;`}
                  data-subcategory={subCategory}
                  data-index={index}
                  data-lightbox-src={image.lightboxSrc}
                  data-original-src={image.originalSrc}
                  data-alt={image.alt}
                  data-caption={image.caption || ''}
                  data-location-name={image.location || ''}
                  data-country-name={image.country || ''}
                >
                  <Image
                    src={image.importedImage || image.src}
                    alt={image.alt}
                    width={Math.round(flexBasis * 2)}
                    height={Math.round(targetHeight * 2)}
                    format="webp"
                    quality={80}
                    class="w-full h-full object-cover rounded-lg transition-transform duration-300 group-hover:scale-110"
                    loading="lazy"
                  />
                  {image.caption && (
                    <div class="absolute inset-0 bg-gradient-to-t from-black/70 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300 rounded-lg">
                      <div class="absolute bottom-0 left-0 right-0 p-4 text-white">
                        <p class="text-sm font-medium">{image.caption}</p>
                        {(image.location || image.country) && (
                          <p class="text-xs text-gray-300">
                            {[image.location, image.country].filter(Boolean).join(', ')}
                          </p>
                        )}
                      </div>
                    </div>
                  )}
                </button>
              );
            })}
          </div>
        </section>
      );
    })}

    {/* Show message if no photos found */}
    {categoryImages.length === 0 && (
      <div class="text-center py-12">
        <p class="text-gray-600 dark:text-gray-400">
          No photos found in {categoryName}.
        </p>
      </div>
    )}
  </div>

  <!-- Lightbox Component -->
  <Lightbox />
</BaseLayout>

<script>
  // Category page lightbox functionality
  function initCategoryPhotos() {
    const categoryPhotoButtons = document.querySelectorAll('.category-photo');

    // Group photos by sub-category
    const photosBySubCategory: Record<string, Array<{
      image: string;
      original: string;
      alt: string;
      title: string;
      location?: string;
      description?: string;
    }>> = {};

    categoryPhotoButtons.forEach((button) => {
      const btn = button as HTMLButtonElement;
      const subCategory = btn.dataset.subcategory || '';
      const locationParts = [btn.dataset.locationName, btn.dataset.countryName]
        .filter(Boolean);

      const photoData = {
        image: btn.dataset.lightboxSrc || '',
        original: btn.dataset.originalSrc || '',
        alt: btn.dataset.alt || '',
        title: btn.dataset.caption || '',
        location: locationParts.join(', '),
        description: '', // Category photos don't have descriptions
      };

      if (!photosBySubCategory[subCategory]) {
        photosBySubCategory[subCategory] = [];
      }
      photosBySubCategory[subCategory].push(photoData);
    });

    // Add click handlers
    categoryPhotoButtons.forEach((photo) => {
      photo.addEventListener('click', (e) => {
        const button = e.currentTarget as HTMLButtonElement;
        const subCategory = button.dataset.subcategory || '';
        const clickedIndex = parseInt(button.dataset.index || '0', 10);

        if ((window as any).openLightbox && photosBySubCategory[subCategory]) {
          (window as any).openLightbox(photosBySubCategory[subCategory], clickedIndex);
        }
      });
    });
  }

  // Initialize on page load
  initCategoryPhotos();

  // Re-initialize on navigation (for Astro view transitions)
  document.addEventListener('astro:page-load', initCategoryPhotos);
</script>
